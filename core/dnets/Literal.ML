signature LITERAL =
sig
	type T
	type multiplicity
	structure G : BANG_GRAPH

	val mk : G.T -> V.name -> T
	val eq : T * T -> bool
	val equiv : T * T -> bool
	val match : T * T -> bool
	

	val get_adj : G.T -> T -> T list

	val get_name : T -> V.name
	val get_kind : T -> G.VData.data
	val get_kind_mult : T -> multiplicity
	val get_input_arity : T -> int
	val get_input_mult : T -> multiplicity
	val get_output_arity : T -> int
	val get_output_mult : T -> multiplicity

	val mult_eq : multiplicity * multiplicity -> bool

	val mult_none : multiplicity
	val mult_star : multiplicity
	val mult_qm : multiplicity

	val fprintf : T -> string

end


functor Literal ( G : BANG_GRAPH ) : LITERAL =
struct

	structure G = G;

	datatype multiplicity = None | Star | QM

	type T = { name : V.name,
			   kind : G.VData.data,
	           kind_mult : multiplicity,
	           input_arity : int,
	           input_mult : multiplicity, 
	           output_arity : int,
	           output_mult : multiplicity }

	(* Helper function to check if all the adjacent nodes are in a bang-box *)
	fun all_bang(g, []) = false
  	  | all_bang(g, v::[]) = G.is_bboxed g v
  	  | all_bang(g, v::vlist) =
      	if G.is_bboxed g v then all_bang(g, vlist)
      	else false

    (* Helper function to check if any of the adjacent nodes is in a bang-box *)
    fun exists_bang(g, []) = false
      | exists_bang (g, v::[]) = G.is_bboxed g v
      | exists_bang (g, v::vlist) =
        if G.is_bboxed g v then true
        else exists_bang(g,vlist)
		
	
	(* Helper functions to get multiplicity *)
	fun compute_kind_mult g v =
	   let
	      val adj_vert = G.adj_vnames g v
	      val v_list = V.NSet.list_of adj_vert
	   in
	     if G.is_bboxed g v then Star
	     else if all_bang(g, v_list) then QM
	         else None
	   end	

	fun compute_input_mult g v =
		let
	      val adj_vert = G.pred_vnames g v
	      val v_list = V.NSet.list_of adj_vert
	   in
	     if exists_bang(g,v_list) then Star
	     else None
	   end

	fun compute_output_mult g v =
		let
	      val adj_vert = G.succ_vnames g v
	      val v_list = V.NSet.list_of adj_vert
	   in
	     if exists_bang(g,v_list) then Star
	     else None
	   end

	(* Make a literal *)   
	fun mk g v = 
		let
			val k = G.get_vertex_data g v
			
			val k_m = compute_kind_mult g v			
			
			val i_a = Arity.get_in (G.get_arity g v)
			
			val i_m = compute_input_mult g v
			
			val o_a = Arity.get_out (G.get_arity g v)

			val o_m = compute_output_mult g v
		in
			{name = v, kind = k, kind_mult = k_m, input_arity = i_a, input_mult = i_m, output_arity = o_a, output_mult = o_m} : T
		end


	(* Helper functions to compare literal matching *)
	fun match_kind(l1,l2) = 
		G.VData.data_eq(#kind l1, #kind l2)

	fun match_input(l1,l2) = 
		if (#input_arity l1 = #input_arity l2) then true
		else if (#input_arity l1 > #input_arity l2) andalso (#input_mult l2 = Star) then true
		     else if (#input_arity l1 < #input_arity l2) andalso (#input_mult l1 = Star) then true
		          else false

	fun match_output(l1,l2) =
		if (#output_arity l1 = #output_arity l2) then true
		else if (#output_arity l1 > #output_arity l2) andalso (#output_mult l2 = Star) then true
		     else if (#output_arity l1 < #output_arity l2) andalso (#output_mult l1 = Star) then true
		          else false

	(* Helper functions to compare literal equivalence *)
	fun equiv_kind(l1,l2) = 
		if (G.VData.data_eq(#kind l1, #kind l2)) andalso
		   ( (#input_mult l1 = None andalso #input_mult l2 = None) orelse
		   	 (#input_mult l1 = Star andalso #input_mult l2 = Star) orelse
		   	 (#input_mult l1 = QM andalso #input_mult l2 = QM) )
		then true
		else false

	fun equiv_input(l1,l2) = 
		if (#input_arity l1 = #input_arity l2) andalso
		   ( (#input_mult l1 = None andalso #input_mult l2 = None) orelse
		   	 (#input_mult l1 = Star andalso #input_mult l2 = Star) )
		then true
		else false

	fun equiv_output(l1,l2) =
		if (#output_arity l1 = #output_arity l2) andalso
		   ( (#output_mult l1 = None andalso #output_mult l2 = None) orelse
		   	 (#output_mult l1 = Star andalso #output_mult l2 = Star) )
		then true
		else false	          


	(* This function checks for matching between c1 and c2, that is if c1 and c2 can match each other *)
    (* TRUE iff l1 and l2 are literals that can be reduced to one another; they can be generated by different node-vertices; they can differ on the multiplicity *)
  	fun match(l1,l2) = match_kind(l1,l2) andalso match_input(l1,l2) andalso match_output(l1,l2)

    (* This function checks for equivalence between c1 and c2, that is if c1 and c2 are equivalent contours *)
    (* TRUE iff l1 and l2 are literals that can be reduced to one another; they can be generated by different node-vertices *)
    fun equiv(l1,l2) = equiv_kind(l1,l2) andalso equiv_input(l1,l2) andalso equiv_output(l1,l2)

	(* This function checks for equality between l1 and l2, that is if l1 and l2 are the same literal *)
    (* TRUE iff l1 and l2 are literals generated by the same node-vertex *)
    fun eq(l1,l2)  = V.name_eq(#name l1, #name l2)

	(* Get the literals of all the adjacent nodes *)
	fun get_adj g l =
		let
	      val adj_vert = G.adj_vnames g (#name l)
	      val v_list = V.NSet.list_of adj_vert

	      val g_list = replicate (length v_list) g

	    in

		  map2 mk g_list v_list    
	      
	    end


	fun get_name(l) = #name l

	fun get_kind(l) = #kind l

	fun get_kind_mult(l) = #kind_mult l

	fun get_input_arity(l) = #input_arity l

	fun get_input_mult(l) = #input_mult l

	fun get_output_arity(l) = #output_arity l

	fun get_output_mult(l) = #output_mult l

	fun mult_eq (m1,m2) =
	  if ((m1=Star andalso m2=Star) orelse (m1=QM andalso m2=QM) orelse (m1=None andalso m2=None)) then true
	  else false

	val mult_none = None

	val mult_qm = QM

	val mult_star = Star


	fun fprintf(l) = V.string_of_name(#name l)

end