(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["Quanto`"]*)
(**)
(*T::usage = "T[m1,m2,...] gives the tensor (Kronecker) product of a list of matrices."*)
(*H::usage = "The 2x2 Hadamard matrix."*)
(*Dag::usage = "Dag[m] gives the daggar (conjugate-transpose) of m."*)
(*Col::usage = "Col[matr,n] pull the nth column from matr."*)
(*zsp::usage = "zsp[angle, in, out] gives a green spider with the given phase, inputs and outputs."*)
(*xsp::usage="xsp[angle, in, out] gives a red spider with the given phase, inputs and outputs."*)
(*sig::usage = "sig[pi1,pi2,...] gives a tensor permutation, sending the input in place N to the output in place piN. sig[1,0] gives the normal swap function."*)
(*id2::usage = "id2[n] gives the n-ary tensor of the 2x2 identity matrix. In other words, it gives the \!\(\*SuperscriptBox[\"2\", \"n\"]\)\!\(\*SuperscriptBox[\"x2\", \"n\"]\) identity matrix."*)
(*PermuteLast::usage="PermuteLast[size,n] permutes the nth qubit all the way to the right."*)
(*PTrace::usage=*)
(*"PTrace[m,inpt,outpt] trace the inpt qubit to the outpt qubit."*)
(**)
(*Begin["`Private`"]*)
(*<<Combinatorica`*)
(*(* red-green calculus standard defns *)*)
(*id=IdentityMatrix[2];*)
(*T[]:={{1}};*)
(*T[X_]:=X;*)
(*T[X_,Y__]:=Simplify[Fold[KroneckerProduct,X,{Y}]];*)
(*id2[n_]:=T@@Table[id,{n}];*)
(*Dag[X_]:=ConjugateTranspose[X];*)
(*rootd=Sqrt[2];*)
(*H={{1,1},{1,-1}};*)
(*b0={{1},{0}};b1={{0},{1}};*)
(*compbasis={b0,b1};*)
(*PermutedTensor[perm_]:=(perm1=Function[x,x+1]/@perm;*)
(*Function[p,Combinatorica`Permute[p,perm1]]/@Tuples[{1,2},Length[perm1]]);*)
(*sig[perm__]:=Function[t,Flatten[T@@t]]/@Function[b,compbasis[[b]]]/@PermutedTensor[{perm}];*)
(*zsp[angle_,in_,out_]:=SparseArray[{{1,1}-> 1, {2^out,2^in}-> \[ExponentialE]^(\[ImaginaryI] angle)}];*)
(*xsp[angle_,in_,out_]:=(1/2)**)
(*T@@Table[H,{out}].zsp[angle,in,out].T@@Table[H,{in}];*)
(*Col[matr_,n_]:=Transpose[{Transpose[matr][[n]]}];*)
(*PermuteLast[size_,elem_]:=Append[Drop[Table[i,{i,0,size-1}],{elem+1}],elem];*)
(*PTrace[m_,qubit1_,qubit2_]:=Module[{bell,ins,outs,sig1,sig2},*)
(*bell=Dag[{{1,0,0,1}}];*)
(*ins=Log[2,Length[m[[1]]]];*)
(*outs=Log[2,Length[m]];*)
(*sig1=Inverse[sig@@PermuteLast[ins,qubit1]];*)
(*sig2=sig@@PermuteLast[outs,qubit2];*)
(*T[id2[outs-1],Dag[bell]].*)
(*T[sig2,id2[1]].*)
(*T[m,id2[1]].*)
(*T[sig1,id2[1]].*)
(*T[id2[ins-1],bell]];*)
(**)
(**)
(*End[]*)
(**)
(*EndPackage[]*)
