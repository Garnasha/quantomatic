signature CONTOUR_LIST =
sig
  type T
  structure G : BANG_GRAPH
  structure C : CONTOUR

  (* CONSTRUCTORS *)
  val empty : T
  val mk : G.T -> T
  val mk_from : G.T -> V.name -> T
  
  (* COMPARISON FUNCTION *)
  val equiv : T * T -> bool 
  
  (* PRINT FUNCTION *)
  val printout : T -> string
end


functor Contour_List (G : BANG_GRAPH) : CONTOUR_LIST =
struct

  structure G = G
  structure LIB = TDNet_Library
  structure C = Contour(G)

  type T = C.T list

  val empty = []

  
  
  (* This function builds contour recursively given a graph g, a previous contour c and a list of remaining literals r. *)
  (* The new contour is added to the contour list cl *)
  fun build_contours(_,_,cl,[]) = rev cl
    | build_contours(_,[],cl,_) = rev cl
    | build_contours(g,c,cl,r) =
    let
      val new_contour = C.mk g c
      val new_contour = C.intersect_eq_contours(new_contour,r)
      val r = C.subtract_eq_contour(r,new_contour)
    in
      if null(new_contour) then build_contours(g,new_contour,cl,r)
      else build_contours(g,new_contour,(new_contour::cl),r)      
    end
  
  (* This function builds a contour list given a graph g *)
  fun mk g = 
    let 
      val first_contour = C.target_function(g)
      val contour_list = first_contour::[]

      val remaining_list = G.get_vertices g
      val remaining_list = V.NSet.list_of remaining_list
      val g_list = replicate (length remaining_list) g
      val remaining_list = map2 C.L.mk g_list remaining_list
      val remaining_list = C.subtract_eq_contour(remaining_list,first_contour)
    in
      build_contours (g,first_contour,contour_list,remaining_list)
    end

  (* This function builds a contour list given a graph g a starting node-vertex v*)
  fun mk_from g v =
    let 
      val first_contour = C.mk_first_contour g v
      val contour_list = first_contour::[]

      val remaining_list = G.get_vertices g
      val remaining_list = V.NSet.list_of remaining_list
      val g_list = replicate (length remaining_list) g
      val remaining_list = map2 C.L.mk g_list remaining_list
      val remaining_list = C.subtract_eq_contour(remaining_list,first_contour)
    in
      build_contours (g,first_contour,contour_list,remaining_list)
    end


  (* This function removes a contour c from a contour list cl, given that c is contained in cl *)
  (* PRECONDITION: c is contained in cl *)
  fun remove_equiv_contour(c,cl) = LIB.rm_element C.equiv c cl

  (* This function checks if a contour c is contained in the contour list cl*)
  fun is_equiv_contour_contained(c,cl) = LIB.is_contained C.equiv c cl

  (* This function checks if two contour lists cl1 and cl2 are equivalent *)
  fun is_equiv_contour_list(c1::[],c2::[]) = if C.equiv(c1,c2) then true else false
    | is_equiv_contour_list(c1::cl1,c2::[]) = if C.equiv(c1,c2) then true else false
    | is_equiv_contour_list(c1::cl1,c2::cl2) = 
      if C.equiv(c1,c2) then is_equiv_contour_list (cl1,cl2)
      else if is_equiv_contour_contained(c1,cl2) then is_equiv_contour_list(cl1,c2::remove_equiv_contour(c1,cl2)) else false
    | is_equiv_contour_list _ = false (* different lengths *)

  (* This function checks for equivalence between cl1 and cl2, that is if cl1 and cl2 are equivalent contour lists *)
  (* TRUE iff cl1 and cl2 contains equivalent contours in any order; they can be generated by different node-vertices *)
  fun equiv (cl1,cl2) =
    if (length cl1 = length cl2) then is_equiv_contour_list(cl1,cl2)
    else false




  (* This function prints the contour list cl*)
  fun printout ([]) = ""
    | printout (c::[]) = C.printout(c)
    | printout (c::cs) = C.printout(c) ^ " " ^ printout(cs) ^ " "

end

